__author__ = 'rcj1492'
__created__ = '2015.12'
__license__ = 'MIT'

'''
PLEASE NOTE:    mandrill requires domain verification to send messages

SETUP:          https://mandrill.zendesk.com/hc/en-us/articles/205582247
'''

# TODO: incorporate rate limiting logic
class mandrillHandler(object):

    ''' handles responses from mandrill api and usage data '''

    _class_fields = {
        'schema': {
            'rate_limits': [
                { 'requests': 25, 'period': 3600 }
            ]
        }
    }

    def __init__(self, usage_client=None):

        '''  
            initialization method for mandrill handler class
        
        :param usage_client: [optional] callable that records usage data
        '''

    # construct class field model
        from jsonmodel.validators import jsonModel
        self.fields = jsonModel(self._class_fields)

    # construct initial methods
        self.rate_limits = self.fields.schema['rate_limits']
        self.usage_client = usage_client

    def handle(self, response):

    # construct default response details
        details = {
            'method': response.request.method,
            'code': response.status_code,
            'url': response.url,
            'error': '',
            'json': None,
            'headers': response.headers
        }

    # handle different codes
        if details['code'] == 200:
            details['json'] = response.json()
        else:
            details['error'] = response.content.decode()

        return details

# TODO: use webscraper & aws api to interact with registration
class mandrillRegister(object):
    ''' currently must be done manually with domain configuration '''
    ''' https://mandrillapp.com/settings '''
    ''' https://mandrill.zendesk.com/hc/en-us/articles/205582267 '''
    def __init__(self):
        pass

class mandrillClient(object):

    ''' a class of methods for sending emails through the mandrill api'''

    # https://mandrillapp.com/api/docs/index.python.html

    _class_fields = {
        'schema': {
            'api_endpoint': 'https://mandrillapp.com/api/1.0',
            'api_key': 'key-e05af44440df8acc78ca21c26680fcc1',
            'recipient_list': ['support@collectiveacuity.com'],
            'sender_email': 'no-reply@collectiveacuity.com',
            'sender_name': 'Collective Acuity',
            'email_subject': 'Test Mailgun API',
            'content_text': 'Great to see it works!',
            'content_html': '<p>Great to see it works!</p>',
            'tracking_tags': ['newsletter'],
            'cc_list': ['support@collectiveacuity.com'],
            'bcc_list': ['support@collectiveacuity.com'],
            'delivery_time': 1490744726.6858199
        }
    }

    def __init__(self, api_key, allow_fees=False, usage_client=None, requests_handler=None):

        '''
            a method to initialize the mandrill client class
            
        :param api_key: string with api key generated by mandrill
        :param allow_fees: [optional] boolean to allow additional fees 
        :param usage_client: callable that records usage data
        :param requests_handler: callable that handles requests errors
        '''

        title = '%s.__init__' % self.__class__.__name__

    # construct class field model
        from jsonmodel.validators import jsonModel
        self.fields = jsonModel(self._class_fields)

    # validate inputs
        input_fields = {
            'api_key': api_key
        }
        for key, value in input_fields.items():
            if value:
                object_title = '%s(%s=%s)' % (title, key, str(value))
                self.fields.validate(value, '.%s' % key, object_title)

    # construct class properties
        self.api_endpoint = self.fields.schema['api_endpoint']
        self.api_key = api_key
        self.allow_fees = allow_fees

    # construct method handlers
        self.service_handler = mandrillHandler(usage_client)
        self.requests_handler = requests_handler

    def _post_request(self, url, json):

        ''' a helper method for handling post requests '''

        import requests

    # construct request kwargs
        request_kwargs = {
            'url': url,
            'json': { 'key': self.api_key }
        }
        request_kwargs['json'].update(**json)

    # send request
        try:
            response = requests.post(**request_kwargs)
        except Exception:
            if self.requests_handler:
                request_kwargs['method'] = 'POST'
                request_object = requests.Request(**request_kwargs)
                return self.requests_handler(request_object)
            else:
                raise

    # handle response
        response_details = self.service_handler.handle(response)

        return response_details

    def send_email(self, recipient_list, sender_email, sender_name, email_subject, content_text='', content_html='', tracking_tags=None, cc_list=None, bcc_list=None, delivery_time=0.0):

        title = '%s.send_email' % __class__.__name__

    # validate inputs
        input_fields = {
            'recipient_list': recipient_list,
            'sender_email': sender_email,
            'sender_name': sender_name,
            'email_subject': email_subject,
            'content_text': content_text,
            'content_html': content_html,
            'tracking_tags': tracking_tags,
            'cc_list': cc_list,
            'bcc_list': bcc_list,
            'delivery_time': delivery_time
        }
        for key, value in input_fields.items():
            if value:
                object_title = '%s(%s=%s)' % (title, key, str(value))
                self.fields.validate(value, '.%s' % key, object_title)

    # construct request kwargs
        request_kwargs = {
            'url': '%s/messages/send.json' % self.api_endpoint,
            'json': {
                'message': {
                    'from_email': sender_email,
                    'from_name': sender_name,
                    'subject': email_subject,
                    'track_opens': True
                },
                'async': False,
                'ip_pool': 'Main Pool'
            }
        }

    # add recipients
        email_list = [ { 'email': email, 'type': 'to' } for email in recipient_list ]
        if cc_list:
            email_list.extend([ {'email': email, 'type': 'cc'} for email in cc_list ])
        if bcc_list:
            email_list.extend([ {'email': email, 'type': 'bcc'} for email in bcc_list ])
        request_kwargs['json']['message']['to'] = email_list

    # add content
        if content_text:
            request_kwargs['json']['message']['text'] = content_text
        elif content_html:
            request_kwargs['json']['message']['html'] = content_html
        else:
            raise IndexError('%s() requires either a content_text or content_html arg.' % title)

    # add optional fields
        if tracking_tags:
            request_kwargs['json']['message']['tags'] = tracking_tags
        if delivery_time:
            if self.allow_fees:
                from time import time
                from labpack.records.time import labDT
                current_time = time()
                if delivery_time - current_time > 0:
                    send_time = labDT.fromEpoch(delivery_time).isoformat().replace('T', ' ')[0:19]
                    request_kwargs['json']['send_at'] = send_time
                else:
                    raise ValueError('%s(delivery_time=%s) must be a future date.' % (title, str(delivery_time)))
            else:
                raise PermissionError('%s(delivery_time) requires allow_fees=True' % title)

    # send request
        response_details = self._post_request(**request_kwargs)

        return response_details

if __name__ == '__main__':

    from labpack.records.settings import load_settings
    mandrill_cred = load_settings('../../../cred/mandrill.yaml')

# construct client
    from labpack.handlers.requests import handle_requests
    mandrill_kwargs = {
        'api_key': mandrill_cred['mandrill_api_key'],
        'requests_handler': handle_requests
    }
    mandrill_client = mandrillClient(**mandrill_kwargs)

# test send email
    from time import time
    email_address = 'support@collectiveacuity.com'
    send_kwargs = {
        'recipient_list': [ email_address ],
        'sender_email': 'no-reply@collectiveacuity.com',
        'sender_name': 'Collective Acuity',
        'email_subject': 'Test Mandrill API %s' % time(),
        'content_text': 'Great to see it works!'
    }
    response_details = mandrill_client.send_email(**send_kwargs)
    assert response_details['code'] == 200
